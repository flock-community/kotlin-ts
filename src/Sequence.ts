import { Iterable } from "@flock/kotlin-ts/Iterable";
import { assert } from "@flock/kotlin-ts/utils";

/**
 * @tsplus type Sequence
 */
export interface Sequence<T> extends Iterable<T> {
  readonly _tag: "Sequence";
}

/**
 * @tsplus type SequenceOps
 */
export interface SequenceOps {}
export const Sequence: SequenceOps = {};

/**
 * @tsplus static SequenceOps __call
 */

export function createSequence<T, P extends [...unknown[]] & { length: 0 }>(
  iteratorFactory: (...args: P) => Iterator<T>
): Sequence<T>;
export function createSequence<T, S, P extends [...unknown[]]>(
  iteratorFactory: (self?: S, ...rest: P) => Iterator<T>
): (self?: S, ...rest: P) => Sequence<T>;
export function createSequence<T, S, P extends [...unknown[]]>(
  iteratorFactory: (self: S, ...rest: P) => Iterator<T>
): (self: S, ...rest: P) => Sequence<T>;
export function createSequence<T, P extends [...unknown[]]>(
  iteratorFactory: (...args: P) => Iterator<T>
): Sequence<T> | ((...args: P) => Sequence<T>) {
  if (iteratorFactory.length === 0) return { _tag: "Sequence", [Symbol.iterator]: iteratorFactory };
  return (...args: P) => ({ _tag: "Sequence", [Symbol.iterator]: () => iteratorFactory(...args) });
}

/**
 * @tsplus static SequenceOps of
 */
export const sequenceOf = <T>(...elements: Array<T>): Sequence<T> => Sequence(() => elements.iterator());

/**
 * @tsplus static SequenceOps generate
 */
export const generateSequence = Sequence(function* <T>(seed: T, next: (t: T) => T) {
  for (let current = seed; ; current = next(current)) yield current;
});

/**
 * Returns a sequence containing only elements from the given sequence
 * having distinct keys returned by the given [selector] function.
 *
 * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.
 * The elements in the resulting sequence are in the same order as they were in the source sequence.
 *
 * The operation is _intermediate_ and _stateful_.
 *
 * @tsplus fluent Sequence distinctBy
 */
export const distinctBy = Sequence(function* <T, K>(self: Sequence<T>, selector: (it: T) => K) {
  const set = new Set<K>();
  for (const e of self) {
    const key = selector(e);
    if (!set.has(key)) {
      yield e;
      set.add(key);
    }
  }
});

/**
 * Returns a sequence containing all elements except first [n] elements.
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @throws IllegalArgumentException if [n] is negative.
 * @tsplus fluent Sequence drop
 */
export const drop = <T>(self: Sequence<T>, n: number) => {
  assert(n >= 0, `Requested element count ${n} is less than zero.`);

  return Sequence(function* () {
    for (const [it, index] of self.withIndex()) if (index >= n) yield it;
  });
};

/**
 * Returns a sequence containing all elements except first elements that satisfy the given [predicate].
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @tsplus fluent Sequence dropWhile
 */
export const dropWhile = Sequence(function* <T>(self: Sequence<T>, predicate: (it: T) => boolean) {
  let yielding = false;
  for (const it of self) {
    if (!predicate(it) || yielding) {
      yield it;
      yielding = true;
    }
  }
});

/**
 * Returns a sequence containing only elements matching the given [predicate].
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @tsplus fluent Sequence filter
 */
export function filter<T, S extends T>(self: Sequence<T>, predicate: (it: T) => it is S): Sequence<S>;
export function filter<T>(self: Sequence<T>, predicate: (it: T) => boolean): Sequence<T>;
export function filter<T>(self: Sequence<T>, predicate: (it: T) => boolean): Sequence<T> {
  return Sequence(function* () {
    for (const it of self) if (predicate(it)) yield it;
  });
}

/**
 * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @tsplus fluent Sequence flatMap
 */
export const flatMap = <T, R>(self: Sequence<T>, transform: (it: T) => Sequence<R>): Sequence<R> =>
  Sequence(function* () {
    for (const it of self) yield* transform(it);
  });

/**
 * Returns a sequence containing the results of applying the given [transform] function
 * to each element in the original sequence.
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @sample samples.collections.Collections.Transformations.map
 * @tsplus fluent Sequence map
 */
export const map = Sequence(function* <T, R>(self: Sequence<T>, transform: (it: T) => R) {
  for (const it of self) yield transform(it);
});

/**
 * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right
 * to each element and current accumulator value that starts with [initial] value.
 *
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting sequence.
 * The [initial] value should also be immutable (or should not be mutated)
 * as it may be passed to [operation] function later because of sequence's lazy nature.
 *
 * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @tsplus fluent Sequence scan
 */
export const scan = <T, R>(self: Iterable<T>, initial: R, operation: (acc: R, it: T) => R): Sequence<R> => {
  return Sequence(function* () {
    yield initial;
    let acc = initial;
    for (const it of self) {
      acc = operation(acc, it);
      yield acc;
    }
  });
};

/**
 * Returns a sequence containing first [n] elements.
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @throws IllegalArgumentException if [n] is negative.
 * @tsplus fluent Sequence take
 */
export const take = <T>(self: Sequence<T>, n: number): Sequence<T> => {
  assert(n >= 0, `Requested element count ${n} is less than zero.`);

  return Sequence(function* () {
    for (const [it, index] of self.withIndex()) if (index < n) yield it;
  });
};

/**
 * Returns a sequence containing first elements satisfying the given [predicate].
 *
 * The operation is _intermediate_ and _stateless_.
 *
 * @tsplus fluent Sequence takeWhile
 */
export function takeWhile<T>(self: Sequence<T>, predicate: (it: T) => boolean): Sequence<T>;
export function takeWhile<T, S extends T>(self: Sequence<T>, predicate: (it: T) => it is S): Sequence<S>;
export function takeWhile<T>(self: Sequence<T>, predicate: (it: T) => boolean): Sequence<T> {
  return Sequence(function* () {
    for (const it of self) {
      if (predicate(it)) yield it;
      else break;
    }
  });
}

/**
 * @tsplus fluent Sequence zip
 */
export const zip = Sequence(<T, R>(self: Sequence<T>, other: Sequence<R>): Iterator<[T, R]> => {
  const iter = self.iterator();
  const otherIter = other.iterator();
  return {
    next(): IteratorResult<[T, R], unknown> {
      const { value, done } = iter.next();
      const { value: otherValue, done: otherDone } = otherIter.next();
      if (done || otherDone) return { value: [value, otherValue], done: true };
      return { value: [value, otherValue], done: done || otherDone };
    },
  };
});
